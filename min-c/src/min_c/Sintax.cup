package min_c;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.*;
import java.io.*;


parser code {:
    public static int erroresSintacticos=0;
    public int cont = 1;
    public static Nodo padre;
    ArrayList output = new ArrayList();

private Symbol s;
    //obtenidos de la clase Token
public String token_name_from_id(int id){
    switch(id){
        case 0: return "EOF";
        case 1: return "error";
        case 2: return "ITSMAIN";
        case 3: return "ITSDECLARE";
        case 4: return "ITSID";
        case 5: return "ITSASSIGNMENT";
        case 6: return "ITSNUMINT";
        case 7: return "ITSSTRING";
        case 8: return "ITSCHAR";
        case 9: return "ITSTRUE";
        case 10: return "ITSFALSE";
        case 11: return "ITSFOR";
        case 12: return "ITSWHILE";
        case 13: return "ITSSWITCH";
        case 14: return "ITSCOLON";
        case 15: return "ITSSCENARIO";
        case 16: return "ITSIF";
        case 17: return "ITSELSE";
        case 18: return "ITSBRK";
        case 19: return "ITSRETURN";
        case 20: return "ITSNULL";
        case 21: return "ITSSEMICOLON";
        case 22: return "ITSOPREL";
        case 23: return "ITSOPMULT";
        case 24: return "ITSOPSUM";
        case 25: return "ITSBRA_L";
        case 26: return "ITSBRA_R";
        case 27: return "ITSPAR_L";
        case 28: return "ITSPAR_R";
        case 29: return "ITSDFT";
        case 30: return "ITSEXIT";
        case 31: return "ITSCOMMENT";
        case 32: return "ITSAND";
        case 33: return "ITSOR";
        case 34: return "ITSINT";
        case 35: return "ITSSTR";
        case 36: return "ITSTHEN";
        case 37: return "ITSVOID";
        case 38: return "ITSBOOLEAN";
        case 39: return "ITSCHARACTER";
        case 40: return "ITSCOMMA";
        case 41: return "ITSFUNCTION";
        case 42: return "ITSL_COMMENT";
        case 43: return "ITSCONST";
        case 44: return "ITSARRAY";
        case 45: return "ITSBRACKET_L";
        case 46: return "ITSBRACKET_R";

        
        default: return "N/A";
    }
}

//adding
public void syntax_error(Symbol s) {

        //report_error("Error de sintaxis. No se esperaba el siguiente token: <" + s.value + ">. linea: " + (s.left ) + ", columna: " + (s.right ) +     "\n", null);
        
        output.add("Error de sintaxis. No se esperaba el siguiente token: <" + s.value + ">. linea: " + (s.left ) + ", columna: " + (s.right ) +     "\n");
        
        erroresSintacticos++;

        List expected = expected_token_ids();
        if (expected.size() != 0) {
            int id;
            //System.out.println("Se esperaba...");
            output.add("Se esperaba...");
            for (int i = 0; i < expected.size(); i++) {
                id = (int) expected.get(i);
                if (i == expected.size() - 1) {
                    //System.out.println(token_name_from_id(id));
                    output.add(token_name_from_id(id));
                } else {
                    //System.out.print(token_name_from_id(id) + " | ");
                    output.add(token_name_from_id(id) + " | ");
                }
            }
        } else { /* do nothing */ }
}
@Override
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        //System.out.println("No se pudo reparar y continuar el análisis.");
        output.add("No se pudo reparar y continuar el análisis.");
    }

:};
terminal ITSMAIN,ITSDECLARE,ITSID,ITSASSIGNMENT,ITSNUMINT,ITSSTRING;
terminal ITSCHAR,ITSTRUE,ITSFALSE,ITSFOR,ITSWHILE,ITSCOLON;
terminal ITSSCENARIO,ITSSWITCH,ITSIF,ITSELSE,ITSBRK,ITSRETURN,ITSNULL,ITSSEMICOLON,ITSOPREL,ITSOPMULT;
terminal ITSOPSUM,ITSBRA_L,ITSBRA_R,ITSPAR_L,ITSPAR_R,ITSDFT,ITSEXIT,ITSCOMMENT;
terminal ITSAND,ITSOR,ITSINT,ITSSTR,ITSTHEN,ITSVOID,ITSBOOLEAN,ITSCHARACTER,ITSCOMMA,ITSFUNCTION;

terminal ITSCONST,ITSARRAY,ITSBRACKET_L,ITSBRACKET_R;

non terminal INICIO,VARIABLE,FUNC,STATEMENTS,COMPARE,CONDITION,VALUE,CALL,DECLARE,ARGS,FUNCS,PARAM;
non terminal FOR,IF,WHILE,COND_AND_OR,ELSE,THEN,SWITCH,SCENARIO,BRK,DFT,TRUE,FALSE,RETURN,NULL,EXIT;
non terminal MAIN,TYPE,STRING,CHAR,L_COMMENT,COMMENT,NUMINT,ID,COMA,SEMICOLON,PAR_R,PAR_L,BRA_R,BRA_L,OPSUM;
non terminal OPMULT,OPREL,ASSIGNMENT,SPECIALCHAR,SPACE,LETTER,DIGIT,ARRAY,FILL,FILLSTRING,FILLCHAR,FILLBOOL,XPR;

precedence left ITSOPMULT;

//GRAMATICA INICIAMOS

start with INICIO;


INICIO ::= ITSMAIN:man ITSBRA_L STATEMENTS:st ITSBRA_R FUNCS:fn
    {:
    parser.output.add("Se ha reconocido el MAIN");
    
    //Nodo nodo = new Nodo();
    //nodo.setEtiqueta("Main");
    //nodo.setID(parser.cont);
    //parser.cont++;

    //nodo.addHijos((Nodo) man);
    //nodo.addHijos((Nodo) st);
    //nodo.addHijos((Nodo) fn);

    //parser.padre = nodo;

    //RESULT = nodo;
    :}
    
;


//funcion o nada
FUNCS::= FUNC FUNCS:s
                |
;


//forma de una funcion void o funcion normal
FUNC::=
 ITSFUNCTION TYPE ITSDECLARE ITSID ITSPAR_L ARGS ITSPAR_R ITSBRA_L STATEMENTS ITSRETURN ITSID ITSBRA_R {:parser.output.add("Se reconocio una funcion");:}
 | ITSFUNCTION ITSVOID ITSDECLARE ITSID ITSPAR_L ARGS ITSPAR_R ITSBRA_L STATEMENTS ITSBRA_R 
{:parser.output.add("Se reconocio una funcion void");:}
;

CALL::= 
    ITSID ITSPAR_L PARAM ITSPAR_R ITSSEMICOLON
        {:parser.output.add("Se llamo a una Funcion.");:}
;
 
//lo que puede ir dentro de ellos mismos
VARIABLE::=
    ITSID ITSOPSUM ITSOPSUM ITSSEMICOLON
    |ITSID ITSASSIGNMENT ITSNUMINT ITSSEMICOLON
    |ITSID ITSASSIGNMENT ITSSTRING ITSSEMICOLON
    |ITSID ITSASSIGNMENT ITSCHARACTER ITSSEMICOLON
    |ITSID ITSASSIGNMENT ITSFALSE ITSSEMICOLON
    |ITSID ITSASSIGNMENT ITSTRUE ITSSEMICOLON
    |ITSID ITSASSIGNMENT ITSID ITSSEMICOLON
    |ITSID ITSASSIGNMENT CALL 
; 
//lo que puede ir dentro de ellos mismos
STATEMENTS::=
    DECLARE STATEMENTS:s
    |ARRAY STATEMENTS:s
    |FOR STATEMENTS:s
    |WHILE STATEMENTS:s
    |IF STATEMENTS:s
    |SWITCH STATEMENTS:s
    |CALL STATEMENTS:s
    |VARIABLE STATEMENTS:s
    |XPR STATEMENTS:s 
    |
;

XPR::=
    ITSID ITSASSIGNMENT ITSNUMINT XPR 
    | ITSOPSUM ITSNUMINT {:parser.output.add("Se detecto OPERACION SUMA O RESTA");:}
    | ITSOPMULT ITSNUMINT {:parser.output.add("Se detecto OPERACION MULT O DIV");:}
;


//argumentos
ARGS::=
    TYPE ITSDECLARE ITSID ITSCOMMA ARGS
    |TYPE ITSDECLARE ITSID
    |
;

PARAM::=
     ITSID PARAM 
    |ITSCOMMA ITSID PARAM
    |
;

FILL::=
    ITSNUMINT  FILL
    |ITSCOMMA ITSNUMINT FILL
    |
;

FILLSTRING::=
    ITSSTRING FILLSTRING
    |ITSCOMMA ITSSTRING FILLSTRING
    |
;

FILLCHAR::=
    ITSCHAR FILLCHAR
    |ITSCOMMA ITSCHAR FILLCHAR
    |
;

FILLBOOL::=
    ITSTRUE FILLBOOL
    |ITSCOMMA ITSTRUE FILLBOOL
    |ITSFALSE FILLBOOL
    |ITSCOMMA ITSFALSE FILLBOOL
    |
;

//todos los demas statements
WHILE::=
    ITSWHILE ITSPAR_L CONDITION ITSPAR_R ITSBRA_L STATEMENTS ITSBRA_R {:parser.output.add("Se detecto un Ciclo While");:}
;

IF::=
    ITSIF ITSPAR_L CONDITION COND_AND_OR ITSPAR_R ITSTHEN ITSBRA_L STATEMENTS ITSBRA_R {:parser.output.add("Se reconocio el bloque if");:}
    |ITSIF ITSPAR_L CONDITION COND_AND_OR ITSPAR_R ITSTHEN ITSBRA_L STATEMENTS ITSBRA_R ITSELSE ITSBRA_L STATEMENTS ITSBRA_R {:parser.output.add("Se reconocio el bloque IFELSE");:}
;

COND_AND_OR::=
    ITSAND CONDITION COND_AND_OR:s
    |ITSOR CONDITION COND_AND_OR:s
    |
;



CONDITION::=
    ITSID ITSOPREL ITSID
    |ITSID ITSOPREL ITSTRUE
    |ITSID ITSOPREL ITSFALSE
    |ITSID ITSOPREL ITSNUMINT
    |ITSTRUE
;

FOR::=
    ITSFOR ITSPAR_L ITSINT ITSDECLARE ITSID ITSASSIGNMENT ITSNUMINT ITSSEMICOLON COMPARE ITSSEMICOLON ITSID ITSOPSUM ITSOPSUM ITSPAR_R ITSBRA_L STATEMENTS ITSBRA_R {:parser.output.add("Se reconocio un ciclo for");:}
;

COMPARE::=
	ITSID ITSOPREL ITSNUMINT
	|ITSNUMINT ITSOPREL ITSID
	|ITSID ITSOPREL ITSID
;



SWITCH::=
    ITSSWITCH ITSPAR_L ITSID ITSPAR_R ITSBRA_L SCENARIO ITSBRA_R {: parser.output.add("Se detecto una declaracion de switch");:}
;   

SCENARIO::=
    ITSSCENARIO ITSNUMINT ITSCOLON STATEMENTS ITSBRK ITSSEMICOLON SCENARIO:s{: parser.output.add("Se detecto una declaracion de scenario");:}
    |ITSSCENARIO ITSCHARACTER ITSCOLON STATEMENTS ITSBRK ITSSEMICOLON SCENARIO:s{: parser.output.add("Se detecto una declaracion de scenario");:}
    |ITSDFT ITSCOLON STATEMENTS ITSBRK ITSSEMICOLON{: parser.output.add("Se detecto una declaracion de dft");:}
    | 

;

DECLARE::=  ITSINT ITSDECLARE ITSID ITSASSIGNMENT ITSNUMINT ITSSEMICOLON {: parser.output.add("Se detecto una declaracion de entero");:}
    |ITSSTR ITSDECLARE ITSID ITSASSIGNMENT ITSSTRING ITSSEMICOLON {:parser.output.add("Se detecto una declaracion de un string");:}
    |ITSCHAR ITSDECLARE ITSID ITSASSIGNMENT ITSCHARACTER ITSSEMICOLON {:parser.output.add("Se detecto una declaracion de un char");:}
    |ITSBOOLEAN ITSDECLARE ITSID ITSASSIGNMENT ITSTRUE ITSSEMICOLON {:parser.output.add("Se detecto una declaracion de un boolean verdadero");:}
    |ITSBOOLEAN ITSDECLARE ITSID ITSASSIGNMENT ITSFALSE ITSSEMICOLON {:parser.output.add("Se detecto una declaracion de un boolean falso");:}
    |ITSINT ITSDECLARE ITSID ITSSEMICOLON {:parser.output.add("Se detecto una declaracion de una variable");:}
    |ITSSTR ITSDECLARE ITSID ITSSEMICOLON {:parser.output.add("Se detecto una declaracion de una variable");:}
    |ITSCHAR ITSDECLARE ITSID ITSSEMICOLON {:parser.output.add("Se detecto una declaracion de una variable");:}
    |ITSBOOLEAN ITSDECLARE ITSID ITSSEMICOLON {:parser.output.add("Se detecto una declaracion de una variable");:}
    |ITSCONST ITSSTR ITSDECLARE ITSID ITSSEMICOLON {:parser.output.add("Se detecto una declaracion de una const string");:}
    |ITSCONST ITSSTR ITSDECLARE ITSID ITSASSIGNMENT ITSSTRING ITSSEMICOLON {:parser.output.add("Se detecto una declaracion de un const string con variable");:}
;



ARRAY::= ITSINT ITSARRAY ITSDECLARE ITSID ITSASSIGNMENT ITSBRACKET_L FILL ITSBRACKET_R ITSSEMICOLON {:parser.output.add("Se detecto una declaracion de un array");:}
        |ITSSTR ITSARRAY ITSDECLARE ITSID ITSASSIGNMENT ITSBRACKET_L FILLSTRING ITSBRACKET_R ITSSEMICOLON {:parser.output.add("Se detecto una declaracion de un array");:}
        |ITSCHAR ITSARRAY ITSDECLARE ITSID ITSASSIGNMENT ITSBRACKET_L FILLCHAR ITSBRACKET_R ITSSEMICOLON {:parser.output.add("Se detecto una declaracion de un array");:}
        |ITSBOOLEAN ITSARRAY ITSDECLARE ITSID ITSASSIGNMENT ITSBRACKET_L FILLBOOL ITSBRACKET_R ITSSEMICOLON {:parser.output.add("Se detecto una declaracion de un array");:}
        |ITSINT ITSARRAY ITSDECLARE ITSID ITSSEMICOLON {:parser.output.add("Se detecto una declaracion de un array");:}        
        |ITSSTR ITSARRAY ITSDECLARE ITSID ITSSEMICOLON {:parser.output.add("Se detecto una declaracion de un array");:}
        |ITSCHAR ITSARRAY ITSDECLARE ITSID ITSSEMICOLON {:parser.output.add("Se detecto una declaracion de un array");:}
        |ITSBOOLEAN ITSARRAY ITSDECLARE ITSID ITSSEMICOLON {:parser.output.add("Se detecto una declaracion de un array");:}
        
;


VALUE::=
    ITSSTRING
    |ITSCHARACTER
    |ITSNUMINT
    |ITSTRUE
    |ITSFALSE
    |
;

TYPE::=
 ITSINT
 |ITSCHAR
 |ITSBOOLEAN
 |ITSSTR
 |
;
